Root cause: the API route is still crashing at module load. That means some top-level code executes before envs are read. Fix by removing all top-level Stripe init and adding a debug route.

Do this exactly.

1) Replace checkout route with lazy init

cd ~/workspace/levqor-site
cat > src/app/api/checkout/route.ts <<'TS'
import { NextResponse } from "next/server";
import Stripe from "stripe";

// force dynamic to avoid caching
export const dynamic = "force-dynamic";

function readEnv() {
  return {
    SECRET: process.env.STRIPE_SECRET_KEY,
    SITE_URL: process.env.SITE_URL || "",
    STARTER_M: process.env.STRIPE_PRICE_STARTER,
    STARTER_Y: process.env.STRIPE_PRICE_STARTER_YEAR,
    PRO_M:     process.env.STRIPE_PRICE_PRO,
    PRO_Y:     process.env.STRIPE_PRICE_PRO_YEAR,
    BIZ_M:     process.env.STRIPE_PRICE_BUSINESS,
    BIZ_Y:     process.env.STRIPE_PRICE_BUSINESS_YEAR,
    ADDON_SUPPORT: process.env.STRIPE_PRICE_ADDON_PRIORITY_SUPPORT,
    ADDON_SLA:     process.env.STRIPE_PRICE_ADDON_SLA_99_9,
    ADDON_WL:      process.env.STRIPE_PRICE_ADDON_WHITE_LABEL,
  };
}

function missingEnv(e: ReturnType<typeof readEnv>) {
  return Object.entries(e).filter(([_k,v]) => !v || String(v).trim()==="").map(([k])=>k);
}

function stripeClient(secret?: string) {
  if (!secret) throw new Error("missing STRIPE_SECRET_KEY");
  return new Stripe(secret, { apiVersion: "2024-06-20" });
}

export async function GET() {
  const env = readEnv();
  const missing = missingEnv(env);
  return NextResponse.json({ ok: missing.length===0, missing });
}

type Body = {
  plan: "starter"|"pro"|"business",
  term: "monthly"|"yearly",
  addons?: ("PRIORITY_SUPPORT"|"SLA_99_9"|"WHITE_LABEL")[]
};

export async function POST(req: Request) {
  try {
    const env = readEnv();
    const miss = missingEnv(env);
    if (miss.length) return NextResponse.json({ ok:false, error:`missing_env:${miss.join(",")}` }, { status:500 });

    const { plan, term, addons=[] } = await req.json() as Body;

    const coreMap: Record<string,string> = {
      "starter:monthly": String(env.STARTER_M),
      "starter:yearly":  String(env.STARTER_Y),
      "pro:monthly":     String(env.PRO_M),
      "pro:yearly":      String(env.PRO_Y),
      "business:monthly":String(env.BIZ_M),
      "business:yearly": String(env.BIZ_Y),
    };
    const core = coreMap[`${plan}:${term}`];
    if (!core) return NextResponse.json({ ok:false, error:"invalid_plan_term" }, { status:400 });

    const addonMap: Record<string,string> = {
      "PRIORITY_SUPPORT": String(env.ADDON_SUPPORT || ""),
      "SLA_99_9":         String(env.ADDON_SLA || ""),
      "WHITE_LABEL":      String(env.ADDON_WL || ""),
    };
    const line_items = [{ price: core, quantity: 1 }].concat(
      addons.map(a => {
        const id = addonMap[a];
        if (!id) throw new Error(`missing_addon_price:${a}`);
        return { price:id, quantity:1 };
      })
    );

    const stripe = stripeClient(env.SECRET);
    const session = await stripe.checkout.sessions.create({
      mode: "subscription",
      line_items,
      allow_promotion_codes: true,
      success_url: `${env.SITE_URL}/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${env.SITE_URL}/pricing?canceled=1`,
    });

    if (!session.url) return NextResponse.json({ ok:false, error:"no_session_url" }, { status:500 });
    return NextResponse.json({ ok:true, url:session.url });
  } catch (err:any) {
    console.error("checkout_error", err);
    return NextResponse.json({ ok:false, error:String(err?.message ?? err) }, { status:500 });
  }
}
TS

2) Add a lightweight debug route

mkdir -p src/app/api/checkout/_debug
cat > src/app/api/checkout/_debug/route.ts <<'TS'
import { NextResponse } from "next/server";
export const dynamic = "force-dynamic";
export async function GET() {
  const keys = [
    "STRIPE_SECRET_KEY","SITE_URL",
    "STRIPE_PRICE_STARTER","STRIPE_PRICE_STARTER_YEAR",
    "STRIPE_PRICE_PRO","STRIPE_PRICE_PRO_YEAR",
    "STRIPE_PRICE_BUSINESS","STRIPE_PRICE_BUSINESS_YEAR",
    "STRIPE_PRICE_ADDON_PRIORITY_SUPPORT",
    "STRIPE_PRICE_ADDON_SLA_99_9",
    "STRIPE_PRICE_ADDON_WHITE_LABEL"
  ];
  const present = keys.filter(k => process.env[k] && String(process.env[k]).trim() !== "");
  const missing = keys.filter(k => !present.includes(k));
  return NextResponse.json({ present, missing });
}
TS

3) Commit and push

git add src/app/api/checkout/route.ts src/app/api/checkout/_debug/route.ts
git commit -m "fix: lazy Stripe init + diagnostics routes"
git push origin main

4) Confirm Production env names match code

Production must have these exact keys and live values:

STRIPE_SECRET_KEY
SITE_URL
STRIPE_PRICE_STARTER
STRIPE_PRICE_STARTER_YEAR
STRIPE_PRICE_PRO
STRIPE_PRICE_PRO_YEAR
STRIPE_PRICE_BUSINESS
STRIPE_PRICE_BUSINESS_YEAR
STRIPE_PRICE_ADDON_PRIORITY_SUPPORT
STRIPE_PRICE_ADDON_SLA_99_9
STRIPE_PRICE_ADDON_WHITE_LABEL

If any are wrong or duplicated under other names, fix with Vercel CLI or dashboard, then redeploy.

5) Test after deploy

# Health: must list [] or missing names
curl -s https://levqor.ai/api/checkout

# Env probe: must show present[] includes STRIPE_SECRET_KEY and all prices
curl -s https://levqor.ai/api/checkout/_debug

# Start a session
curl -s -X POST https://levqor.ai/api/checkout \
  -H "content-type: application/json" \
  --data '{"plan":"starter","term":"monthly"}'

curl -s -X POST https://levqor.ai/api/checkout \
  -H "content-type: application/json" \
  --data '{"plan":"business","term":"yearly","addons":["PRIORITY_SUPPORT","SLA_99_9","WHITE_LABEL"]}'

Expected: {"ok":true,"url":"https://checkout.stripe.com/..."}

6) If still 500, pull logs immediately

Use one of:

# CLI (needs token)
vercel logs levqor-site --since 30m --prod --token "$VERCEL_TOKEN"

# or Dashboard: Project → Functions → Production → Recent invocations → View logs

Search for: checkout_error, missing STRIPE_SECRET_KEY, or any stack trace. Share the exact log line if something remains.

This removes the crash class and gives you a deterministic health endpoint. After this, failures will be visible as JSON errors or in Vercel logs, not silent 500s.