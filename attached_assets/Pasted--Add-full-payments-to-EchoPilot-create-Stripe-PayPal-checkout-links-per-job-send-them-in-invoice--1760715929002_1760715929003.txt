> Add full payments to EchoPilot: create Stripe/PayPal checkout links per job, send them in invoice email/PDF, receive webhooks to flip “Payment Status” automatically, and run a nightly reconciliation for missed hooks. Keep Gmail/Telegram alerts intact.



0) Install/confirm deps

pip install stripe requests cryptography


---

1) Create/replace payments.py

# payments.py
import os, json, base64, hmac, hashlib, time, requests, stripe

# ---- Provider config
STRIPE_KEY = os.getenv("STRIPE_SECRET_KEY","").strip()
STRIPE_WH_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET","").strip()
PAYPAL_ID  = os.getenv("PAYPAL_CLIENT_ID","").strip()
PAYPAL_SEC = os.getenv("PAYPAL_SECRET","").strip()
PAYPAL_LIVE = os.getenv("PAYPAL_LIVE","true").lower()=="true"

CURRENCY   = os.getenv("PAYMENT_CURRENCY","USD").upper()
SUCCESS_URL= os.getenv("PAYMENT_SUCCESS_URL","https://example.com/success")
CANCEL_URL = os.getenv("PAYMENT_CANCEL_URL","https://example.com/cancel")
BRAND_NAME = os.getenv("PAYMENT_BRAND_NAME","EchoPilot AI")

# ---- Stripe: create checkout link
def stripe_create_checkout(amount_usd: float, job_id: str, client_email: str|None=None):
    if not STRIPE_KEY: raise RuntimeError("STRIPE_SECRET_KEY missing")
    stripe.api_key = STRIPE_KEY
    cents = int(round(amount_usd*100))
    session = stripe.checkout.Session.create(
        mode="payment",
        payment_method_types=["card"],
        line_items=[{
            "price_data":{
                "currency": CURRENCY.lower(),
                "unit_amount": cents,
                "product_data":{"name": f"{BRAND_NAME} Job {job_id}"}
            },
            "quantity": 1
        }],
        customer_email=client_email or None,
        success_url=f"{SUCCESS_URL}?job={job_id}&status=success",
        cancel_url =f"{CANCEL_URL}?job={job_id}&status=cancel",
        metadata={"job_id": job_id}
    )
    return {"provider":"stripe","amount":amount_usd,"currency":CURRENCY,"url":session.url,"id":session.id}

# ---- Stripe: verify webhook & parse
def stripe_parse_webhook(payload: bytes, sig_header: str):
    if not STRIPE_WH_SECRET: raise RuntimeError("STRIPE_WEBHOOK_SECRET missing")
    try:
        event = stripe.Webhook.construct_event(payload, sig_header, STRIPE_WH_SECRET)
        typ = event["type"]
        data = event["data"]["object"]
        job_id = (data.get("metadata") or {}).get("job_id") or \
                 (data.get("payment_link") or {}).get("metadata",{}).get("job_id")
        status = None
        if typ in ("checkout.session.completed","payment_intent.succeeded"):
            status = "Paid"
        elif typ in ("payment_intent.payment_failed","checkout.session.expired"):
            status = "Cancelled"
        return {"ok": True, "provider":"stripe", "type": typ, "job_id": job_id, "status": status}
    except Exception as e:
        return {"ok": False, "error": str(e)}

# ---- PayPal helpers
def _paypal_base():
    host = "https://api-m.paypal.com" if PAYPAL_LIVE else "https://api-m.sandbox.paypal.com"
    return host

def paypal_token():
    auth = base64.b64encode(f"{PAYPAL_ID}:{PAYPAL_SEC}".encode()).decode()
    r = requests.post(_paypal_base()+"/v1/oauth2/token",
        headers={"Authorization":f"Basic {auth}"},
        data={"grant_type":"client_credentials"}, timeout=20)
    r.raise_for_status(); return r.json()["access_token"]

def paypal_create_order(amount_usd: float, job_id: str):
    token = paypal_token()
    body = {
      "intent":"CAPTURE",
      "purchase_units":[{
        "reference_id": job_id,
        "amount":{"currency_code": CURRENCY, "value": f"{amount_usd:.2f}"},
        "description": f"{BRAND_NAME} Job {job_id}"
      }],
      "application_context":{
        "brand_name": BRAND_NAME,
        "return_url": f"{SUCCESS_URL}?job={job_id}&status=success",
        "cancel_url": f"{CANCEL_URL}?job={job_id}&status=cancel",
        "shipping_preference":"NO_SHIPPING","user_action":"PAY_NOW"
      }
    }
    r = requests.post(_paypal_base()+"/v2/checkout/orders",
        headers={"Authorization":f"Bearer {token}","Content-Type":"application/json"},
        json=body, timeout=20)
    r.raise_for_status()
    data=r.json()
    approve = next((l["href"] for l in data["links"] if l["rel"]=="approve"), None)
    return {"provider":"paypal","amount":amount_usd,"currency":CURRENCY,"url":approve,"id":data["id"]}

def paypal_capture(order_id: str):
    token = paypal_token()
    r = requests.post(_paypal_base()+f"/v2/checkout/orders/{order_id}/capture",
        headers={"Authorization":f"Bearer {token}","Content-Type":"application/json"},
        timeout=20)
    r.raise_for_status(); return r.json()

def paypal_parse_webhook(body: dict):
    # Minimal parse: PayPal webhooks come signed via headers; for simplicity, rely on order capture poller.
    # We accept 'CHECKOUT.ORDER.APPROVED' or capture outcome from our reconciliation.
    event_type = body.get("event_type")
    resource = body.get("resource", {})
    job_id = (resource.get("purchase_units") or [{}])[0].get("reference_id")
    status = None
    if event_type in ("CHECKOUT.ORDER.APPROVED","PAYMENT.CAPTURE.COMPLETED"):
        status = "Paid"
    elif event_type in ("CHECKOUT.ORDER.CANCELLED","PAYMENT.CAPTURE.DENIED"):
        status = "Cancelled"
    return {"ok": True, "provider":"paypal","type": event_type, "job_id": job_id, "status": status}

# ---- Unified creator
def create_payment_link(amount_usd: float, job_id: str, client_email: str|None=None):
    if STRIPE_KEY:
        return stripe_create_checkout(amount_usd, job_id, client_email)
    elif PAYPAL_ID and PAYPAL_SEC:
        return paypal_create_order(amount_usd, job_id)
    else:
        raise RuntimeError("No payment provider configured")


---

2) Patch invoice sending to include link (if not already)

In your processor where you already generate the invoice PDF:

from payments import create_payment_link
# ...
amount_to_charge = rev["gross"]
pay = create_payment_link(amount_to_charge, job_id, client_email)
notion_update_fields(job_id,{
    "Payment Status":{"select":{"name":"Unpaid"}},
    "Payment Link":{"url": pay["url"]},
})
deliver_invoice(client_email,
    f"[EchoPilot] Invoice {job_id}",
    f"Your EchoPilot job is complete.\nAmount due: ${amount_to_charge:.2f}\nGross: ${rev['gross']:.2f}\nProfit: ${rev['profit']:.2f}",
    pdf_bytes,
    payment_link=pay["url"]
)


---

3) Add webhooks (Flask routes) in main.py (if web build; if bot-only, skip)

# main.py
from flask import request, jsonify
from payments import stripe_parse_webhook, paypal_parse_webhook
# assumes you have notion_update_fields(job_id, { ... }) helper

@app.post("/webhook/stripe")
def wh_stripe():
    sig = request.headers.get("Stripe-Signature","")
    outcome = stripe_parse_webhook(request.data, sig)
    if not outcome.get("ok"): return jsonify(outcome), 400
    job = outcome.get("job_id"); status = outcome.get("status")
    if job and status:
        notion_update_fields(job, {"Payment Status":{"select":{"name": status}}})
    return jsonify({"ok": True})

@app.post("/webhook/paypal")
def wh_paypal():
    body = request.get_json(silent=True) or {}
    outcome = paypal_parse_webhook(body)
    job = outcome.get("job_id"); status = outcome.get("status")
    if job and status:
        notion_update_fields(job, {"Payment Status":{"select":{"name": status}}})
    return jsonify({"ok": True})


---

4) Notion fields (one-time)

Ensure EchoPilot Job Log has:

Payment Link (URL)

Payment Status (Select: Unpaid, Paid, Cancelled)
(If missing, open Job Log → Notion AI: “Create these properties with exact names and types.”)



---

5) Nightly reconciliation (missed hooks, PayPal capture)

Create reconcile_payments.py and schedule daily.

# reconcile_payments.py
import os, requests, datetime, time, json
from payments import paypal_capture, PAYPAL_ID, PAYPAL_SEC
from alert_mailer import send_alert

H={"Authorization":f"Bearer {os.getenv('NOTION_API_KEY','')}","Notion-Version":"2022-06-28","Content-Type":"application/json"}
DB=os.getenv("NOTION_DB_ID","")

def _query_unpaid():
    q={"filter":{"property":"Payment Status","select":{"equals":"Unpaid"}},"page_size":100}
    r=requests.post(f"https://api.notion.com/v1/databases/{DB}/query",headers=H,json=q,timeout=30).json()
    return r.get("results",[])

def _get_prop(page, name, typ):
    p=page["properties"].get(name,{}); return p.get(typ)

def reconcile_once():
    pages=_query_unpaid()
    changed=0
    for pg in pages:
        pid=pg["id"]
        link=_get_prop(pg,"Payment Link","url")
        if not link: continue
        # If PayPal link & we have order id in URL, try capture (best effort)
        if "paypal.com" in link and PAYPAL_ID and PAYPAL_SEC:
            try:
                # naive extraction of order id from link
                if "token=" in link:
                    order_id = link.split("token=")[-1].split("&")[0]
                    cap = paypal_capture(order_id)
                    # If capture succeeded, mark paid
                    if any(v.get("status")=="COMPLETED" for v in cap.get("purchase_units",[{}])[0].get("payments",{}).get("captures",[])):
                        requests.patch(f"https://api.notion.com/v1/pages/{pid}",headers=H,
                            json={"properties":{"Payment Status":{"select":{"name":"Paid"}}}}, timeout=20)
                        changed+=1
                        continue
            except Exception as e:
                print("PayPal capture error:", e)
        # TODO: Stripe reconciliation via list events requires Stripe secret; webhook is primary
    if changed:
        send_alert("[EchoPilot] Reconciliation updates", f"Marked {changed} invoice(s) Paid via reconciliation.")
    return changed

Add to your scheduler (in main.py or bot.py), once:

from threading import Thread
import time, datetime
from reconcile_payments import reconcile_once

def schedule_reconciliation(hour_utc=2, minute=10):
    def loop():
        while True:
            now = datetime.datetime.utcnow()
            if now.hour==hour_utc and now.minute==minute:
                try:
                    n=reconcile_once()
                    print("[Reconcile] changed:", n)
                except Exception as e:
                    print("[Reconcile] error:", e)
                time.sleep(70)
            time.sleep(20)
    Thread(target=loop, daemon=True).start()

schedule_reconciliation()


---

6) Secrets / Env (Replit + Railway)

# Stripe (preferred)
STRIPE_SECRET_KEY=sk_live_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx

# OR PayPal
PAYPAL_CLIENT_ID=xxx
PAYPAL_SECRET=xxx
PAYPAL_LIVE=true      # false for sandbox

PAYMENT_CURRENCY=USD
PAYMENT_BRAND_NAME=EchoPilot AI
PAYMENT_SUCCESS_URL=https://<yourapp>/pay/success
PAYMENT_CANCEL_URL=https://<yourapp>/pay/cancel

> In Stripe dashboard: create a webhook endpoint pointing to https://<yourapp>/webhook/stripe with event checkout.session.completed (and optionally payment_intent.succeeded, checkout.session.expired).
In PayPal: set webhooks to https://<yourapp>/webhook/paypal for CHECKOUT.ORDER.APPROVED and PAYMENT.CAPTURE.COMPLETED (optional because we also reconcile).




---

7) 60-sec Smoke Test

Run a short job → Notion row should get Payment Link + Unpaid.

Click the link → complete payment (Stripe test mode or PayPal sandbox).

Within seconds (webhook) the Job Log’s Payment Status flips to Paid.

If webhooks are blocked, it flips during the 2:10 UTC reconciliation.