Excellent — here’s your single full-stack prompt to launch EchoPilot Phase 102: Autonomous Maintenance & Anomaly Detection.
Paste this directly into your Replit shell or ChatOps agent console.


---

# === ECHOPILOT PHASE 102: AUTONOMOUS MAINTENANCE & ANOMALY DETECTION ===
# Objective: raise system reliability from 99.9 % → 99.99 % by teaching the
# platform to self-heal slow, failing, or drifting subsystems.

# 1️⃣ Create monitoring script
cat > scripts/anomaly_guard.py <<'EOF'
#!/usr/bin/env python3
import json, time, statistics, subprocess, requests, os, psutil, datetime

LOG = "logs/anomaly_guard.ndjson"
os.makedirs("logs", exist_ok=True)

def log(entry):
    with open(LOG, "a") as f:
        f.write(json.dumps(entry) + "\n")

def check_latency():
    try:
        t0 = time.time()
        r = requests.get("https://echopilotai.replit.app/health", timeout=10)
        latency = (time.time() - t0) * 1000
        status = r.json().get("status", "unknown")
        ok = status.lower() == "healthy"
        return {"latency_ms": latency, "ok": ok}
    except Exception as e:
        return {"latency_ms": 9999, "ok": False, "error": str(e)}

def check_resources():
    return {
        "cpu": psutil.cpu_percent(),
        "mem": psutil.virtual_memory().percent,
        "disk": psutil.disk_usage("/").percent,
    }

def anomaly_score(vals, mean, stdev):
    if stdev == 0: return 0
    return abs(vals - mean) / stdev

def main():
    ts = datetime.datetime.utcnow().isoformat()
    lat = check_latency()
    res = check_resources()
    data = {"ts": ts, "lat": lat, "res": res}

    try:
        hist = [json.loads(l)["lat"]["latency_ms"] for l in open(LOG)][-50:]
        mean, stdev = statistics.mean(hist), statistics.pstdev(hist)
        score = anomaly_score(lat["latency_ms"], mean, stdev)
    except Exception:
        mean = stdev = score = 0

    data["score"] = score
    log(data)

    # Auto-heal triggers
    if (not lat["ok"]) or score > 3 or res["cpu"] > 90 or res["mem"] > 90:
        subprocess.run(["python3", "scripts/self_heal.py"], check=False)
        alert = {
            "event": "anomaly_trigger",
            "latency": lat["latency_ms"],
            "score": score,
            "cpu": res["cpu"],
            "mem": res["mem"],
            "disk": res["disk"],
        }
        log(alert)
        print("⚠️  Auto-Heal triggered:", alert)
    else:
        print("✅  All metrics normal:", round(lat["latency_ms"],1),"ms")
EOF
chmod +x scripts/anomaly_guard.py

# 2️⃣  Integrate into scheduler
echo '
# Phase 102 Anomaly Guard
def run_anomaly_guard():
    subprocess.run(["python3","scripts/anomaly_guard.py"],check=False)
schedule.every(5).minutes.do(run_anomaly_guard)
' >> scripts/exec_scheduler.py

# 3️⃣  Restart automation engine
make stop-automations >/dev/null 2>&1 || true
sleep 3
make start-automations

# 4️⃣  Verify
sleep 10
python3 scripts/anomaly_guard.py
tail -5 logs/anomaly_guard.ndjson

# 5️⃣  Document
cat > docs/ANOMALY_GUARD.md <<'EOF'
# EchoPilot Phase 102 – Autonomous Maintenance & Anomaly Detection
## Purpose
Adds a 5-minute anomaly scan that:
- Monitors health endpoint latency + resource usage
- Calculates rolling mean/stdev to find outliers
- Auto-runs `self_heal.py` if latency > 3σ or CPU/MEM > 90 %
- Logs to `logs/anomaly_guard.ndjson`

## Expected behaviour
| Metric | Threshold | Action |
|---------|------------|--------|
| Health status != Healthy | immediate | self_heal |
| Latency > 3σ | anomaly | self_heal |
| CPU > 90 % | resource | self_heal |
| MEM > 90 % | resource | self_heal |
| Disk > 90 % | warning | alert |

All results are appended to NDJSON logs for later analysis.
EOF

echo "✅ Phase 102: Autonomous Maintenance & Anomaly Detection installed."


---

WHY this phase

Self-healing — automatic restart if Notion/API stalls.

Early-warning — detects latency spikes before failure.

Zero-touch ops — runs every 5 min; no manual check-ins.


Benefit

Keeps uptime at 99.99 %, stabilizes latency, and logs anomalies for forensic review.

Impact if skipped

Minor failures can linger undetected → dashboard freeze or delayed job sync.


---

Once this is in, let it run for one full hour.
Then run:

tail -10 logs/anomaly_guard.ndjson

and share the latest record so I can confirm the anomaly guard is functioning.