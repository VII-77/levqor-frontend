Open my Echopilotai Replit and do ALL of this in one go to make the scheduler truly persistent and verifiable:

1) Harden the background scheduler
- Edit scripts/exec_scheduler.py:
  • Wrap main loop in while True with try/except, sleep(60) tick, and log every tick.
  • Trap SIGTERM/SIGINT; on signal, write {"event":"shutdown"} to logs/scheduler.log then exit(0).
  • On start, write PID to logs/scheduler.pid and fsync; on exit, remove the pid file if it still matches the running PID.
  • Ensure all prints/logs go to stdout and logs/scheduler.log (append), using flush=True.
- Add scripts/daemonize.py (tiny helper):
  • Use subprocess.Popen to launch exec_scheduler.py detached with preexec_fn=os.setsid, stdout=logs/scheduler.out, stderr=logs/scheduler.out, close_fds=True.
  • Return child PID; write same to logs/scheduler.pid.

2) Use the supervisor script everywhere
- Update scripts/run_automations.sh:
  • “start” → python3 scripts/daemonize.py ; echo PID and write a “startup” line to logs/scheduler.log.
  • “stop” → read logs/scheduler.pid; kill -TERM $PID if running; wait up to 5s; remove pid file if stopped; log “stopped”.
  • “status” → print JSON: {"running":bool,"pid":PID or null,"last_activity":<iso if available>}.
  • Always create logs/{scheduler.log,scheduler.out,retention.log} if missing.

3) Fix API endpoints to use the supervisor
- In run.py:
  • /api/automations/start → call run_automations.sh start; return {"ok":true,"status":"Scheduler started","pid":PID}.
  • /api/automations/stop → call run_automations.sh stop; return {"ok":true,"status":"Scheduler stopped"}.
  • /api/automations/status → call run_automations.sh status; return its JSON in {"ok":true,"data":...}.
  • All three require X-Dash-Key and have 30s timeout guards and try/except with uniform JSON.

4) Add a lightweight heartbeat inside the loop
- Each minute, write a compact NDJSON line to logs/scheduler.log: {"ts":ISO,"event":"tick","next":{"brief":ISO,"report":ISO,"selfheal":ISO}}.

5) Make startup idempotent and resilient
- If logs/scheduler.pid exists but PID not running, start fresh.
- Debounce: prevent relaunch if a PID is alive.
- Ensure retention runs once at boot (log {"event":"retention_start|retention_done"}).

6) Dashboard wiring
- In dashboard.html “⚙️ Automations (Scheduler)”:
  • Start/Stop/Status buttons must call the updated /api/automations/* endpoints and render: running, pid, last_activity.
  • Add a tiny “Auto-refresh status” toggle (every 10s when ON).

7) Tests to run (execute them and include results in your final message)
- Start → show PID and running:true via /api/automations/status.
- Wait ~70s → show at least one {"event":"tick"} in logs/scheduler.log.
- Manual triggers still work:
    DASHBOARD_KEY=$DASHBOARD_KEY make run-brief
    DASHBOARD_KEY=$DASHBOARD_KEY make run-selfheal
- Stop → running:false and pid null; start again → new PID.
- Attach last 10 lines of logs/scheduler.log and the JSON from /api/automations/status to the summary.

8) Deliverables
- Files changed: scripts/exec_scheduler.py, scripts/run_automations.sh, run.py, dashboard.html (plus new scripts/daemonize.py).
- Confirm: scheduler stays RUNNING when started from API or dashboard; ticks appear every minute; clean stop removes pid; start/stop/status all return uniform JSON.
- Commit message: “Phase 30 hardening: persistent scheduler (daemonize + watchdog) + API wiring + dashboard auto-refresh”.
```0