ROLE
You are the Release Captain for Levqor. Run a full-system validation that proves new pages are served fresh, correlation IDs propagate end-to-end, intelligence API logging is correct, and burn-in/Go-No-Go metrics are tracked. Diagnose, fix, and re-verify in one pass.

INPUTS (edit if needed)
DOMAIN=levqor.ai
API_HOST=api.levqor.ai
VERCEL_PROJECT=levqor-site
CLOUDFLARE=yes            # yes|no
NEXT_ROUTER=app           # app|pages
PWA_SW=no                 # yes|no
CID=burn-in-$(date +%s)   # correlation ID for tracing

TOOLS REQUIRED
- bash, curl, jq, grep
- access to Vercel and Cloudflare consoles (if CLOUDFLARE=yes)

SUCCESS CRITERIA
A) Landing HTML never cached: Cache-Control=no-store, Age absent/0, x-vercel-cache MISS on first hit.
B) Static assets hashed and cached long-term.
C) Correlation ID echoes through API response meta.correlation_id and appears in logs.
D) Performance meta.duration_ms present and sane (1..10000 ms typical).
E) No generic {"error":"internal_error"} leaks from global error handler on handled paths during burn-in.
F) Burn-in monitors show Error Rate ≤0.5%, P1=0, Daily Cost ≤$10; history accrues daily.
G) All 5 intelligence endpoints respond 2xx with structured fields or a typed error object.

PHASE 0 — PRE-FLIGHT
set -euo pipefail
echo "Using DOMAIN=$DOMAIN API_HOST=$API_HOST CID=$CID"
command -v jq >/dev/null || { echo "Install jq"; exit 1; }

PHASE 1 — HTML FRESHNESS & CACHE VALIDATION
echo "== HTML headers"
for u in "https://$DOMAIN" "https://www.$DOMAIN" "https://$DOMAIN/" "https://$DOMAIN/?t=$RANDOM"; do
  echo "--- $u"
  curl -sI "$u" | grep -iE 'HTTP/|cache-control|age: |x-vercel-cache|content-type|location'
done

echo "== Expectations"
echo "Expect text/html; Cache-Control: no-store; Age: absent/0; x-vercel-cache: MISS on first request."

echo "== Asset cache check"
HTML=$(curl -s "https://$DOMAIN")
ASSET=$(printf "%s" "$HTML" | grep -oE "/_next/static/[^\"']+\\.js" | head -1 || true)
if [ -n "$ASSET" ]; then
  echo "Asset: $ASSET"
  curl -sI "https://$DOMAIN$ASSET" | grep -iE 'cache-control|age: |x-vercel-cache|content-length'
  echo "Expect long max-age and HIT after warm."
else
  echo "No Next.js asset detected on landing. If this is intentional, skip."
fi

PHASE 2 — OPTIONAL SW/PWA CHECK
if [ "$PWA_SW" = "yes" ]; then
  echo "Ensure service worker does NOT cache HTML navigations. Manual step:"
  echo "Chrome DevTools → Application → Service Workers → Unregister. Then reload and retest Phase 1."
fi

PHASE 3 — EDGE/CDN RULES
if [ "$CLOUDFLARE" = "yes" ]; then
  echo "Confirm Cloudflare Cache Rule: content-type contains text/html → BYPASS."
  echo "Confirm Cloudflare respects origin Cache-Control for others. Purge Everything once if Phase 1 fails."
fi

PHASE 4 — API INTELLIGENCE: CORRELATION, DURATION, STRUCTURE
echo "== Intelligence endpoints with CID=$CID"
EPS=(status anomalies forecasts recommendations health)
for e in "${EPS[@]}"; do
  URL="https://$API_HOST/api/intelligence/$e"
  echo "--- $URL"
  RESP=$(curl -s -H "X-Request-ID: $CID" "$URL" || true)
  echo "$RESP" | jq . || echo "$RESP"
  echo "Check fields: meta.correlation_id == $CID OR echo in body/logs; meta.duration_ms present; timestamp present."
done

echo "== Validate structured logging surface"
echo "Greppable markers expected in server logs: intel_status.ok, correlation id ($CID), duration_ms, anomalies_24h, health_error_rate."

PHASE 5 — ERROR-HANDLER SANITY
echo "== Negative test (expect typed JSON with error.type, not generic internal_error)"
NEG_URL="https://$API_HOST/api/intelligence/forecasts?start=INVALID_DATE"
NEG=$(curl -s -H "X-Request-ID: $CID-neg" "$NEG_URL" || true)
echo "$NEG" | jq . || echo "$NEG"
echo "Expect error object with type/message/metadata. If only {\"error\":\"internal_error\"}, the global handler is masking."

echo "== If masking detected, propose patch (do not deploy blindly):"
cat <<'PY' >/tmp/error_handler_patch.example.py
# In run.py or your app factory, limit the catch-all and include correlation id
from werkzeug.exceptions import HTTPException
from flask import jsonify, request
import traceback, os

@app.errorhandler(Exception)
def handle_any(e):
    cid = request.headers.get("X-Request-ID") or request.headers.get("X-Correlation-ID")
    debug = os.getenv("INTEL_DEBUG_ERRORS","false").lower() == "true"
    if isinstance(e, HTTPException):
        payload = {"error": {"type": e.__class__.__name__, "message": e.description, "status": e.code, "correlation_id": cid}}
        return jsonify(payload), e.code
    # Non-HTTP errors
    payload = {"error": {"type": e.__class__.__name__, "message": str(e), "status": 500, "correlation_id": cid}}
    if debug:
        payload["error"]["trace"] = traceback.format_exc()
    return jsonify(payload), 500
PY
echo "Ensure real endpoint code returns typed errors so this handler passes them through."

PHASE 6 — BURN-IN HEALTH CHECKS
echo "== Platform health"
curl -s "https://$API_HOST/public/metrics" | jq . || true

echo "== Go/No-Go dashboard script"
python3 scripts/monitoring/notion_go_nogo_dashboard.py || true

echo "== Tail recent synthetic/alert logs (informational)"
grep -hE "synthetic|alert" /tmp/logs/levqor-backend_*.log | tail -50 || true

echo "== Day-0 thresholds"
echo "Expect: ErrorRate<=0.5%, P1=0, DailyCost<=\$10; 7d uptime and 7 Intel-API days will accrue over time."

PHASE 7 — GUARDED REMEDIATION IF HTML WAS CACHED
HTML_CACHED=false
HCHECK=$(curl -sI "https://$DOMAIN" | tr '[:upper:]' '[:lower:]')
echo "$HCHECK" | grep -q "text/html" || true
echo "$HCHECK" | grep -q "cache-control: no-store" || HTML_CACHED=true
echo "$HCHECK" | grep -qE "^age: [1-9]" && HTML_CACHED=true
echo "$HCHECK" | grep -q "x-vercel-cache: hit" && HTML_CACHED=true

if [ "$HTML_CACHED" = "true" ]; then
  echo "== Apply origin headers fix (choose one):"
  echo "Option A: next.config.js headers()"
  cat <<'JS' >/tmp/next.config.headers.example.js
module.exports = {
  async headers() {
    return [
      {
        source: "/:path*",
        has: [{ type: "header", key: "Accept", value: ".*text/html.*" }],
        headers: [{ key: "Cache-Control", value: "no-store" }],
      },
    ];
  },
};
JS
  echo "Option B: per-route (App Router)"
  cat <<'TS' >/tmp/route_headers.example.ts
// In app/(marketing)/page.tsx or layout:
export const revalidate = 0;
export const dynamic = "force-dynamic";
TS
  echo "After change: trigger a production deploy and re-run PHASE 1."
  echo "If Cloudflare in front: Purge Everything and ensure HTML bypass rule."
fi

PHASE 8 — CI SMOKE TEST (commit this script)
cat <<'SH' >/tmp/check_cache.sh
#!/usr/bin/env bash
set -euo pipefail
u="https://'"$DOMAIN"'"
h=$(curl -sI "$u")
echo "$h"
echo "$h" | grep -qi "text/html"
echo "$h" | grep -qi "cache-control: no-store"
! echo "$h" | grep -qi "^age: [1-9]" || { echo "ERROR: HTML served from cache"; exit 1; }
SH
chmod +x /tmp/check_cache.sh
echo "Add /tmp/check_cache.sh to post-deploy CI; fail on error."

PHASE 9 — REPORT OUT
echo "== OUTPUT REQUIRED"
echo "1) Paste HTML header snapshots before/after."
echo "2) Paste one asset header showing long cache."
echo "3) Paste one intelligence endpoint JSON with meta.correlation_id=$CID and duration_ms."
echo "4) If error-handler changed, paste diff snippet."
echo "5) State Go/No-Go Day-0 metrics (ErrorRate, P1, Cost)."

DONE