# ======================================================
# PHASE 3 — PARTNER API + REGISTRY
# ======================================================

mkdir -p modules/partner_api
touch modules/partner_api/{registry.py,hooks.py,auth.py,notion_sync.py}

# registry.py
# Central Partner registration table + CRUD
cat > modules/partner_api/registry.py << 'PY'
import uuid, datetime as dt
from flask import Blueprint, request, jsonify
from utils.db import db

bp = Blueprint("partner_registry", __name__)

@bp.route("/api/partners/register", methods=["POST"])
def register_partner():
    data = request.get_json()
    pid = str(uuid.uuid4())
    entry = {
        "id": pid,
        "name": data.get("name"),
        "email": data.get("email"),
        "webhook_url": data.get("webhook_url"),
        "share": data.get("share", 0.7),
        "verified": False,
        "created_at": dt.datetime.utcnow().isoformat(),
    }
    db.table("partners").insert(entry)
    return jsonify({"id": pid, "status": "pending_approval"})

@bp.route("/api/partners", methods=["GET"])
def list_partners():
    partners = db.table("partners").all()
    return jsonify({"partners": partners})
PY

# hooks.py
cat > modules/partner_api/hooks.py << 'PY'
import requests
def trigger_partner_event(partner, event, payload):
    try:
        requests.post(partner["webhook_url"], json={"event": event, "payload": payload}, timeout=5)
    except Exception:
        pass
PY

# auth.py — Partner token validation (simple HMAC or JWT)
# notion_sync.py — pushes partner entries to Notion "Partner Registry" DB for transparency

# Register blueprint in app/run.py
# Create DB table: partners (id, name, email, webhook_url, share, verified, created_at)

# WHY: enables third-party registration for modules
# BENEFIT: infinite feature growth
# IMPACT IF IGNORED: stagnation; closed ecosystem

# ======================================================
# PHASE 4 — MARKETPLACE + STRIPE CONNECT PAYOUTS
# ======================================================

mkdir -p modules/marketplace
touch modules/marketplace/{listings.py,payouts.py,notion_sync.py}

# listings.py
cat > modules/marketplace/listings.py << 'PY'
from flask import Blueprint, request, jsonify
from utils.db import db
bp = Blueprint("marketplace", __name__)

@bp.route("/api/marketplace/listings", methods=["GET"])
def get_listings():
    return jsonify({"listings": db.table("listings").all()})

@bp.route("/api/marketplace/listings", methods=["POST"])
def create_listing():
    d = request.get_json()
    item = {
        "id": d.get("id"),
        "name": d.get("name"),
        "description": d.get("description"),
        "price": d.get("price"),
        "partner_id": d.get("partner_id"),
        "verified": False
    }
    db.table("listings").insert(item)
    return jsonify({"status": "created"})
PY

# payouts.py — use Stripe Connect to distribute partner revenue
cat > modules/marketplace/payouts.py << 'PY'
import stripe, os
stripe.api_key = os.environ["STRIPE_SECRET_KEY"]

def pay_partner(amount_cents:int, partner_account:str):
    stripe.Transfer.create(
        amount=amount_cents,
        currency="usd",
        destination=partner_account,
        description="Levqor Marketplace Payout"
    )
PY

# notion_sync.py — mirrors listings to Notion “Marketplace Catalog” DB

# FRONTEND: Marketplace Page
mkdir -p levqor-site/src/app/marketplace
cat > levqor-site/src/app/marketplace/page.tsx << 'TSX'
'use client';
import { useEffect, useState } from 'react';
export default function Marketplace() {
  const [items,setItems]=useState<any[]>([]);
  useEffect(()=>{ fetch('/api/marketplace/listings').then(r=>r.json()).then(d=>setItems(d.listings||[])); },[]);
  return (
    <div className="max-w-5xl mx-auto p-6 space-y-4">
      <h1 className="text-3xl font-bold">Levqor Marketplace</h1>
      <p className="text-sm text-gray-500">Discover partner-built modules and templates.</p>
      <div className="grid md:grid-cols-3 gap-4">
        {items.map(i=>(
          <div key={i.id} className="border rounded-2xl p-4">
            <div className="text-xl font-semibold">{i.name}</div>
            <div className="text-sm">{i.description}</div>
            <div className="mt-2 text-lg">${i.price}</div>
            <button className="mt-3 border rounded-xl px-3 py-1">Buy</button>
          </div>
        ))}
      </div>
    </div>
  );
}
TSX

# STRIPE CONNECT SETUP:
# 1. Enable Connect (Standard accounts) in Stripe dashboard
# 2. Add partner_account_id field in partners table
# 3. Revenue share: default 70% partner / 30% Levqor
# 4. Use payouts.py to send monthly transfers via scheduled job

# WHY: external developers can sell add-ons
# BENEFIT: new revenue + network effects
# IMPACT IF IGNORED: limited feature diversity

# ======================================================
# PHASE 5 — GOVERNANCE, AUDITING, AND POLICY
# ======================================================

mkdir -p modules/governance
touch modules/governance/{policy.json,audit.py,review_cycle.py}

# policy.json
cat > modules/governance/policy.json << 'JSON'
{
  "revenue_share_default": 0.7,
  "approval_required": true,
  "forbidden_apis": ["/auth/root","/internal/"],
  "review_cycle_days": 90
}
JSON

# audit.py
cat > modules/governance/audit.py << 'PY'
import datetime as dt
from utils.db import db
from modules.partner_api.hooks import trigger_partner_event

def run_audit():
    partners = db.table("partners").all()
    for p in partners:
        trigger_partner_event(p, "audit_notice", {"date": dt.date.today().isoformat()})
    db.table("audits").insert({"timestamp": dt.datetime.utcnow().isoformat(), "partners_checked": len(partners)})
PY

# review_cycle.py
cat > modules/governance/review_cycle.py << 'PY'
import datetime as dt
from utils.db import db
def due_for_review():
    partners = db.table("partners").all()
    cutoff = dt.datetime.utcnow() - dt.timedelta(days=90)
    return [p for p in partners if dt.datetime.fromisoformat(p["created_at"]) < cutoff]
PY

# Schedule quarterly audit job in APScheduler:
# scripts/automation/partner_audit.py → runs audit.py + posts to Notion “Audit Logs” DB

# WHY: maintain security, fairness, and trust
# BENEFIT: prevents malicious modules, keeps brand clean
# IMPACT IF IGNORED: potential exploits, revenue leakage

# ======================================================
# FINALIZATION — v6.0 PLATFORM INTEGRATION
# ======================================================

# 1. DOCUMENTATION
mkdir -p docs/partners
cat > docs/partners/README.md << 'MD'
# Levqor Partner API
## Register
POST /api/partners/register
→ {id, status}
## Create Listing
POST /api/marketplace/listings
→ {status:created}
## Webhooks
Partners receive JSON POSTs on key events.
## Revenue
70/30 default split. Stripe Connect used for payouts.
MD

# 2. PULSE METRICS INTEGRATION
# Extend weekly_pulse.py
# Add fields:
#   partners_total = len(db.table("partners"))
#   marketplace_sales = count from listings/orders
#   payouts_made = count from payout logs

# 3. COST DASHBOARD
# Add Stripe fee tracking for Connect transfers
# Field: "Partner Payouts"

# 4. FRONTEND NAV
# Add "Marketplace" link to site navbar

# 5. SECURITY
# Validate partner registration inputs
# Sanitize webhook URLs (https only)
# Verify Connect payouts via test transfers first

# 6. VALIDATION
# a) Register partner → POST /api/partners/register
# b) Partner creates listing → POST /api/marketplace/listings
# c) Listing visible on https://levqor.ai/marketplace
# d) Trigger payout (test account) → logs to Notion
# e) Run quarterly audit job manually once → log to Audit DB