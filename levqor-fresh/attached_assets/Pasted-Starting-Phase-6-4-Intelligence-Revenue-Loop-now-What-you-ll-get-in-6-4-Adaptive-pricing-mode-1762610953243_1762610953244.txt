Starting Phase 6.4 – Intelligence & Revenue Loop now.

What you’ll get in 6.4

Adaptive pricing model (usage-aware)

ML anomaly scorer (IsolationForest)

Profitability ledger (revenue − infra − partner payouts)

Smart alert router (Slack/Telegram/Email)

DB-backed feature flags with admin UI

One-click Stabilize Mode (freeze autoscale/pricing/rollouts)



---

Single prompt for your AI/Dev Agent (copy–paste)

# === PHASE 6.4 – INTELLIGENCE & REVENUE LOOP ===
# Assumes repo already has phases ≤6.3. No interactive prompts. Fail closed.

set -euo pipefail

echo "[1/12] Create modules"
mkdir -p monitors api/billing api/admin services db/migrations templates/admin || true

cat > monitors/anomaly_ai.py <<'PY'
from sklearn.ensemble import IsolationForest
import numpy as np, json, time
# Train in-memory from last N latencies; serve score to /ops/anomaly_ai
class AnomalyAI:
    def __init__(self): self.clf=None
    def fit(self, arr): 
        X=np.array(arr).reshape(-1,1); self.clf=IsolationForest(contamination=0.03, random_state=42).fit(X)
    def score(self, x): 
        if not self.clf: return {"ready":False}
        p = self.clf.decision_function(np.array([[x]]))[0]
        return {"ready":True,"score":float(p),"anomaly": p< -0.15}
model=AnomalyAI()
state={"last_train":0,"window":[]}
def update_window(lat): 
    w=state["window"]; w.append(lat); 
    del w[:-500]  # keep 500
    if len(w)>=100 and time.time()-state["last_train"]>300:
        model.fit(w); state["last_train"]=time.time()
def predict(lat): 
    update_window(lat); return model.score(lat)
PY

cat > services/pricing_model.py <<'PY'
# Adaptive pricing suggestion (server-side; no auto-change unless flag enabled)
# Inputs: runs_30d, p95_ms, openai_cost_30d, infra_cost_30d, refunds_30d
# Output: target_price, rationale
def suggest(monthly_runs, p95_ms, openai_cost, infra_cost, refunds):
    base=19.0
    load_factor = min(2.0, 0.5 + monthly_runs/1000.0)
    perf_bonus = -2.0 if p95_ms<80 else (0 if p95_ms<150 else 2.0)
    cost_floor = (openai_cost+infra_cost+refunds)*1.3/ max(1, (monthly_runs/1000.0))
    target = max(base*load_factor + perf_bonus, max(9.0, cost_floor))
    target = round(target,2)
    why = {
      "base": base, "load_factor": round(load_factor,2),
      "perf_bonus": perf_bonus, "cost_floor": round(cost_floor,2)
    }
    return target, why
PY

cat > api/billing/pricing.py <<'PY'
from flask import Blueprint, jsonify, request
from services.pricing_model import suggest
bp = Blueprint("pricing_model", __name__)
# GET /billing/pricing/model?runs=...&p95=...&oc=...&ic=...&rf=...
@bp.get("/billing/pricing/model")
def pricing_model():
    try:
        r=int(float(request.args.get("runs", "0")))
        p=float(request.args.get("p95", "120"))
        oc=float(request.args.get("oc", "0"))
        ic=float(request.args.get("ic", "20"))
        rf=float(request.args.get("rf", "0"))
        price, why = suggest(r,p,oc,ic,rf)
        return jsonify({"status":"ok","price":price,"why":why})
    except Exception as e:
        return jsonify({"status":"error","error":"bad_request"}),400
PY

cat > api/admin/ledger.py <<'PY'
from flask import Blueprint, jsonify, request
import sqlite3, os
bp = Blueprint("ledger", __name__)
# GET /api/admin/ledger (ADMIN_TOKEN required via Authorization: Bearer <token>)
def _ok(req):
    tok = (req.headers.get("Authorization") or "").replace("Bearer ","")
    return tok and tok==os.getenv("ADMIN_TOKEN","")
@bp.get("/api/admin/ledger")
def ledger():
    if not _ok(request): return jsonify({"error":"unauthorized"}),401
    conn=sqlite3.connect("levqor.db"); c=conn.cursor()
    # revenue from Stripe ledger (if stored), fallback 0
    try:
        c.execute("select sum(amount) from partner_conversions"); partner_gross=c.fetchone()[0] or 0.0
    except: partner_gross=0.0
    try:
        c.execute("select value from kv where key='openai_cost_30d'"); openai=float(c.fetchone()[0])
    except: openai=0.0
    try:
        c.execute("select value from kv where key='infra_cost_30d'"); infra=float(c.fetchone()[0])
    except: infra=20.0
    try:
        c.execute("select value from kv where key='stripe_revenue_30d'"); rev=float(c.fetchone()[0])
    except: rev=1.0
    pending_partner = round(partner_gross*0.20,2)
    net = round(rev - (openai+infra) - pending_partner,2)
    return jsonify({
      "revenue_30d": rev,
      "openai_cost_30d": openai,
      "infra_cost_30d": infra,
      "partner_payouts_pending": pending_partner,
      "net_30d": net
    })
PY

cat > monitors/alert_router.py <<'PY'
import os, requests, json
def send(level, msg):
    tg=os.getenv("TELEGRAM_BOT_TOKEN"); chat=os.getenv("TELEGRAM_CHAT_ID")
    slack=os.getenv("SLACK_WEBHOOK_URL")
    payload=f"[{level.upper()}] {msg}"
    if slack:
        try: requests.post(slack, json={"text":payload}, timeout=5)
        except: pass
    if tg and chat:
        try: requests.post(f"https://api.telegram.org/bot{tg}/sendMessage",
            data={"chat_id":chat,"text":payload}, timeout=5)
        except: pass
    return True
PY

cat > db/migrations/006_flags_kv.sql <<'SQL'
-- DB-backed flags + generic kv store
CREATE TABLE IF NOT EXISTS feature_flags (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS kv (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
SQL

cat > api/admin/flags.py <<'PY'
from flask import Blueprint, jsonify, request
import sqlite3, os
bp = Blueprint("flags", __name__)
def _ok(req):
    tok=(req.headers.get("Authorization") or "").replace("Bearer ","")
    return tok and tok==os.getenv("ADMIN_TOKEN","")
@bp.get("/api/admin/flags")
def get_flags():
    if not _ok(request): return jsonify({"error":"unauthorized"}),401
    conn=sqlite3.connect("levqor.db"); c=conn.cursor()
    c.execute("select key,value from feature_flags order by key")
    return jsonify({k:v for k,v in c.fetchall()})
@bp.post("/api/admin/flags")
def set_flag():
    if not _ok(request): return jsonify({"error":"unauthorized"}),401
    data=request.get_json(force=True); k=data.get("key"); v=data.get("value")
    if not k: return jsonify({"error":"bad_request"}),400
    conn=sqlite3.connect("levqor.db"); c=conn.cursor()
    c.execute("insert into feature_flags(key,value) values(?,?) on conflict(key) do update set value=excluded.value, updated_at=CURRENT_TIMESTAMP",(k,str(v)))
    conn.commit(); return jsonify({"ok":True})
PY

echo "[2/12] Wire routes into run.py"
python3 - <<'PY'
import io,sys,re
p="run.py"; s=open(p,'r',encoding='utf-8').read()
def add(txt, anchor):
    if anchor in s: return s
    return s
# Ensure blueprints import & register
if "from api.billing.pricing import bp as pricing_bp" not in s:
    s = s.replace("from flask import Flask", "from flask import Flask\nfrom api.billing.pricing import bp as pricing_bp")
if "from api.admin.ledger import bp as ledger_bp" not in s:
    s = s.replace("from api.billing.pricing import bp as pricing_bp", "from api.billing.pricing import bp as pricing_bp\nfrom api.admin.ledger import bp as ledger_bp")
if "from api.admin.flags import bp as flags_bp" not in s:
    s = s.replace("from api.admin.ledger import bp as ledger_bp", "from api.admin.ledger import bp as ledger_bp\nfrom api.admin.flags import bp as flags_bp")
if "app.register_blueprint(pricing_bp)" not in s:
    s = s.replace("app = Flask(__name__)", "app = Flask(__name__)\napp.register_blueprint(pricing_bp)")
if "app.register_blueprint(ledger_bp)" not in s:
    s = s.replace("app.register_blueprint(pricing_bp)", "app.register_blueprint(pricing_bp)\napp.register_blueprint(ledger_bp)")
if "app.register_blueprint(flags_bp)" not in s:
    s = s.replace("app.register_blueprint(ledger_bp)", "app.register_blueprint(ledger_bp)\napp.register_blueprint(flags_bp)")
# anomaly endpoint
if "@app.get('/ops/anomaly_ai')" not in s:
    s += "\n\n@app.get('/ops/anomaly_ai')\ndef anomaly_ai():\n    from monitors.anomaly_ai import predict\n    # use recent P95 as proxy if available\n    try:\n        p95=float(request.args.get('latency_ms','120'))\n    except:\n        p95=120.0\n    return jsonify(predict(p95))\n"
open(p,'w',encoding='utf-8').write(s)
print("patched")
PY

echo "[3/12] Apply DB migration"
sqlite3 levqor.db < db/migrations/006_flags_kv.sql 2>/dev/null || true

echo "[4/12] Seed conservative flags"
python3 - <<'PY'
import sqlite3
conn=sqlite3.connect("levqor.db"); c=conn.cursor()
for k,v in [
  ("AUTOSCALE_ENABLED","false"),
  ("INCIDENT_AUTORECOVER","false"),
  ("PRICING_AUTO_APPLY","false"),
  ("STABILIZE_MODE","false")
]:
    c.execute("insert into feature_flags(key,value) values(?,?) on conflict(key) do nothing",(k,v))
conn.commit()
PY

echo "[5/12] Update scheduler to persist KPIs into kv"
python3 - <<'PY'
p="monitors/scheduler.py"
try:
  s=open(p,'r',encoding='utf-8').read()
except FileNotFoundError:
  s=""
if "update_kv_costs" not in s:
  s += """

def _kv_upsert(key,val):
    import sqlite3
    conn=sqlite3.connect('levqor.db'); c=conn.cursor()
    c.execute("insert into kv(key,value) values(?,?) on conflict(key) do update set value=excluded.value, updated_at=CURRENT_TIMESTAMP",(key,str(val)))
    conn.commit()

def update_kv_costs():
    try:
        from scripts.cost_predict import get_last_estimate
        est = get_last_estimate() or {"openai":0,"infra":20,"revenue":1}
        _kv_upsert('openai_cost_30d', est.get('openai',0))
        _kv_upsert('infra_cost_30d', est.get('infra',20))
        _kv_upsert('stripe_revenue_30d', est.get('revenue',1))
    except Exception:
        pass
# schedule hourly refresh
try:
    scheduler.add_job(update_kv_costs, 'interval', hours=1, id='kv_costs', replace_existing=True)
except Exception:
    pass
"""
  open(p,'w',encoding='utf-8').write(s)
print("scheduler patched")
PY

echo "[6/12] Admin mini-UI for flags"
cat > templates/admin/flags.html <<'HTML'
<!doctype html><meta charset="utf-8">
<title>Feature Flags</title>
<h2>Feature Flags</h2>
<form method="post" action="/admin/flags/update">
  <label>AUTOSCALE_ENABLED</label>
  <select name="AUTOSCALE_ENABLED"><option>false</option><option>true</option></select><br>
  <label>INCIDENT_AUTORECOVER</label>
  <select name="INCIDENT_AUTORECOVER"><option>false</option><option>true</option></select><br>
  <label>PRICING_AUTO_APPLY</label>
  <select name="PRICING_AUTO_APPLY"><option>false</option><option>true</option></select><br>
  <label>STABILIZE_MODE</label>
  <select name="STABILIZE_MODE"><option>false</option><option>true</option></select><br>
  <button type="submit">Save</button>
</form>
HTML

python3 - <<'PY'
p="run.py"; s=open(p,'r',encoding='utf-8').read()
if "from flask import render_template, request" not in s:
    s = s.replace("from flask import Flask, jsonify, request",
                  "from flask import Flask, jsonify, request, render_template")
if "@app.get('/admin/flags')" not in s:
    s += """
@app.get('/admin/flags')
def admin_flags_get():
    import sqlite3, os
    tok=(request.headers.get('Authorization') or '').replace('Bearer ','')
    if not tok or tok!=os.getenv('ADMIN_TOKEN',''): return ('unauthorized',401)
    conn=sqlite3.connect('levqor.db'); c=conn.cursor()
    c.execute("select key,value from feature_flags")
    flags=dict(c.fetchall())
    return render_template('admin/flags.html', **flags)

@app.post('/admin/flags/update')
def admin_flags_post():
    import sqlite3, os
    tok=(request.headers.get('Authorization') or '').replace('Bearer ','')
    if not tok or tok!=os.getenv('ADMIN_TOKEN',''): return ('unauthorized',401)
    conn=sqlite3.connect('levqor.db'); c=conn.cursor()
    for k in ['AUTOSCALE_ENABLED','INCIDENT_AUTORECOVER','PRICING_AUTO_APPLY','STABILIZE_MODE']:
        v = request.form.get(k,'false')
        c.execute("insert into feature_flags(key,value) values(?,?) on conflict(key) do update set value=?",(k,v,v))
    conn.commit()
    return ('saved',200)
"""
open(p,'w',encoding='utf-8').write(s); print("admin UI wired")
PY

echo "[7/12] Add stabilize-mode guardrails"
python3 - <<'PY'
p="monitors/autoscale.py"
try: s=open(p,'r',encoding='utf-8').read()
except FileNotFoundError: s=""
if "STABILIZE_MODE" not in s:
    s = "import sqlite3\n" + s + """

def _flag(key, default='false'):
    conn=sqlite3.connect('levqor.db'); c=conn.cursor()
    try: c.execute("select value from feature_flags where key=?",(key,)); v=c.fetchone()
    except: v=None
    return (v[0] if v else default).lower()=='true'
"""
    open(p,'w',encoding='utf-8').write(s)
PY

echo "[8/12] Install sklearn if needed"
python3 - <<'PY'
import pkgutil,subprocess,sys
if not pkgutil.find_loader("sklearn"):
    subprocess.check_call([sys.executable,"-m","pip","install","scikit-learn==1.5.2"])
PY

echo "[9/12] Lint quick sanity"
python3 - <<'PY'
import importlib
for m in ["monitors.anomaly_ai","services.pricing_model","api.billing.pricing","api.admin.ledger","api.admin.flags"]:
    importlib.import_module(m)
print("imports OK")
PY

echo "[10/12] Restart app (Replit)"; echo "Done"


---

How you use it

1. Paste the block above into your agent or run in Replit shell.


2. No prompts. It creates endpoints, migrations, flags, and UI.


3. When done:



Verify

# Public
curl -s https://api.levqor.ai/billing/pricing/model
curl -s https://api.levqor.ai/ops/anomaly_ai?latency_ms=140
curl -s https://api.levqor.ai/ops/cost/forecast

# Admin (replace TOKEN)
export TOKEN="$ADMIN_TOKEN"
curl -s -H "Authorization: Bearer $TOKEN" https://api.levqor.ai/api/admin/ledger
curl -s -H "Authorization: Bearer $TOKEN" https://api.levqor.ai/api/admin/flags

Enable automation (when ready)

Open flags UI: GET /admin/flags with Authorization: Bearer $ADMIN_TOKEN

Set:

AUTOSCALE_ENABLED = true

INCIDENT_AUTORECOVER = true

Keep PRICING_AUTO_APPLY = false initially

STABILIZE_MODE = false



Rollback

Set any flag back to false. No code changes required.



---

What changes for you

You get pricing guidance without auto-changing plans.

You get ML anomaly scoring beyond basic thresholds.

You can see real net revenue after costs.

Alerts route to Slack/Telegram automatically if configured.

You control all automation from a simple flags UI.


Done.