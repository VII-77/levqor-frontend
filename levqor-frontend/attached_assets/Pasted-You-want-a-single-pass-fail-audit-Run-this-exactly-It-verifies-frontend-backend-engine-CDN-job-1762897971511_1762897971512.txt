You want a single pass/fail audit. Run this exactly. It verifies frontend, backend, engine, CDN, jobs, and DB-facing APIs.

#!/usr/bin/env bash
set -euo pipefail

echo "=== FRONTEND (Vercel + Cloudflare) ==="
curl -sI https://levqor.ai | grep -iE 'HTTP/|server:|cache-control:|x-vercel-cache:|age:|cf-cache-status:' || true
CSS=$(curl -s https://levqor.ai | grep -oE '/_next/static/[^"]+\.css' | head -1 || true)
JS=$(curl -s https://levqor.ai | grep -oE '/_next/static/[^"]+\.js'  | head -1 || true)
echo "CSS:$CSS"; [ -n "$CSS" ] && curl -sI "https://levqor.ai$CSS" | grep -i "200" || echo "CSS MISSING"
echo "JS:$JS";   [ -n "$JS" ]   && curl -sI "https://levqor.ai$JS"  | grep -i "200" || echo "JS MISSING"
echo
echo "robots.txt (first lines)"; curl -s https://levqor.ai/robots.txt | head -3 || true

echo; echo "=== BACKEND API (Replit) ==="
curl -s https://api.levqor.ai/api/intelligence/status | jq -r '{ok: .ok // "n/a", version: .version // "n/a", meta: .meta}'

echo; echo "=== ENGINE HEALTH ==="
/usr/bin/env bash -lc 'curl -s https://api.levqor.ai/api/intelligence/health | jq -r "."' || echo "engine health endpoint not reachable"

echo; echo "=== PUBLIC METRICS ==="
curl -s https://api.levqor.ai/public/metrics | jq -r "." || echo "metrics endpoint not reachable"

echo; echo "=== CORRELATION-ID ECHO ==="
CID="audit-$(date +%s)"
curl -s -H "X-Request-ID: $CID" https://api.levqor.ai/api/intelligence/status | jq -r ".meta.correlation_id"
echo "sent CID: $CID"

echo; echo "=== CDN BEHAVIOR ==="
curl -sI https://levqor.ai | grep -iE 'x-vercel-cache:|cf-cache-status:|age:'
ASSET=$(curl -s https://levqor.ai | grep -oE '/_next/static/[^"]+\.js' | head -1)
curl -sI "https://levqor.ai$ASSET" | grep -iE 'cache-control:|cf-cache-status:|age:'

echo; echo "=== SIGN-IN ROUTE ==="
curl -sI https://levqor.ai/signin | head -5

echo; echo "=== SUMMARY ==="
echo "Expectations:"
echo "- Frontend HTML: no-store, age:0, x-vercel-cache: MISS, server: cloudflare"
echo "- CSS/JS: HTTP 200 with 'public, max-age=31536000, immutable'"
echo "- /api/intelligence/status: version = v8.0-burnin, meta.correlation_id present"
echo "- /api/intelligence/health: returns JSON with zero errors"
echo "- /public/metrics: JSON present"

Pass criteria

Frontend: cache-control: no-store, age: 0, x-vercel-cache: MISS, server: cloudflare. CSS and JS return 200.

Backend: /api/intelligence/status returns version and meta.correlation_id equals the sent header value. /api/intelligence/health returns JSON with no criticals. /public/metrics returns JSON.

CDN: asset request shows long-lived cache; HTML shows cf-cache-status: DYNAMIC or BYPASS.


If any check fails

HTML stale: Vercel → Promote latest deployment; Cloudflare → Purge home page; confirm age: 0.

CSS/JS 404: rebuild and deploy frontend; ensure no server fetch(..., {cache:"no-store"}) inside Server Components; keep export const dynamic="force-dynamic"; export const revalidate=0; in layout.tsx.

Status/health 500: clear Python bytecode cache and restart:

find . -type d -name __pycache__ -exec rm -rf {} +; pkill -f gunicorn || true

Correlation-ID mismatch: confirm global error handler passes X-Request-ID through and responses include meta.correlation_id.

Metrics missing: verify /public/metrics route and DB connectivity; check Neon URL and SSL mode.


Optional hardening (fast)

Cloudflare rate limit: /api/* → 100 req/min/IP → Block or Managed Challenge.

Enable 2FA on Vercel, Cloudflare, Stripe, GitHub, Neon, Replit.


Run the script and paste any failing section. I’ll give the exact one-liner fix per failure.